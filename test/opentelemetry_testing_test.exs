defmodule OpentelemetryTestingTest do
  use ExUnit.Case, async: true
  import :span_collector, only: [build_span_tree: 3]

  # Use Record module to extract fields of the Span record from the opentelemetry dependency.
  require Record
  @fields Record.extract(:span, from_lib: "opentelemetry/include/otel_span.hrl")
  # Define macros for `Span`.
  Record.defrecordp(:span, @fields)

  test "OpentelemetryTesting.ensure_started/0 is idempotent" do
    assert :ok == OpentelemetryTesting.ensure_started()
    assert :ok == OpentelemetryTesting.ensure_started()
  end

  test "OpentelemetryTesting.convert_span/1 is equivalent to :opentelemetry_testing.convert_span/1" do
    span_trees_input_data = Enum.take(SpanTreeGenerator.span_tree_input_data_gen(6, 6), 10)

    tree_patterns = :span_tree_builder.generate_linked_span_trees(span_trees_input_data, & &1)

    for {%{trace_id: trace_id, span_id: span_id}, _} <- tree_patterns do
      assert {:ok, %{}} = OpentelemetryTesting.wait_for_span(trace_id, span_id, 300)

      assert build_span_tree(trace_id, span_id, &OpentelemetryTesting.convert_span/1) ==
               build_span_tree(trace_id, span_id, &:opentelemetry_testing.convert_span/1)
    end
  end

  test "OpentelemetryTesting.convert_span/1 doesn't crash on unexpected input" do
    assert %{attributes: :undefined, events: :undefined, links: :undefined} =
             OpentelemetryTesting.convert_span(span())
  end

  @tag capture_log: true
  test "OpentelemetryTesting.wait_for_span/3 returns errors" do
    span_tree_input_data = {%{name: "some_span_name"}, [{%{name: "some_span_name"}, []}]}

    {%{trace_id: trace_id, span_id: span_id}, _} =
      :span_tree_builder.generate_span_tree(span_tree_input_data, & &1)

    OpentelemetryTesting.wait_for_span(trace_id, span_id, 300)

    ## we have 2 spans with this trace_id
    assert {:error, :span_is_not_unique} == OpentelemetryTesting.wait_for_span(trace_id, :_, 0)
  end

  # @tag capture_log: true
  test "OpentelemetryTesting.build_span_tree/2 returns errors" do
    span_tree_input_data = {%{name: "some_span_name"}, [{%{name: "some_span_name"}, []}]}

    {%{trace_id: trace_id, span_id: span_id}, _} =
      :span_tree_builder.generate_span_tree(span_tree_input_data, & &1)

    OpentelemetryTesting.wait_for_span(trace_id, span_id, 300)

    ## we have 2 spans with this trace_id
    assert {:error, :span_is_not_unique} == OpentelemetryTesting.build_span_tree(trace_id, :_)
  end

  test "OpentelemetryTesting.get_span_ids_by_name/1 returns errors" do
    IO.inspect(__ENV__.function, label: :test_function_name)
    ## span_name is much longer than the names generated by SpanTreeGenerator
    span_name = elem(__ENV__.function, 0)
    span_tree_input_data = {%{name: span_name}, [{%{name: span_name}, []}]}
    {%{span_id: span_id}, _} = :span_tree_builder.generate_span_tree(span_tree_input_data, & &1)
    ## we have 2 spans with this span name
    assert {:ok, %{}} = OpentelemetryTesting.wait_for_span(:_, span_id, 300)
    assert {:error, :span_is_not_unique} == OpentelemetryTesting.get_span_ids_by_name(span_name)
  end

  test "OpentelemetryTesting.get_span_ids_by_name/1 returns trace and span ids" do
    IO.inspect(__ENV__.function, label: :test_function_name)
    ## span_name is much longer than the names generated by SpanTreeGenerator
    span_name = elem(__ENV__.function, 0)
    span_tree_input_data = {%{name: span_name}, []}

    {%{trace_id: trace_id, span_id: span_id}, _} =
      :span_tree_builder.generate_span_tree(span_tree_input_data, & &1)

    assert {:ok, %{}} = OpentelemetryTesting.wait_for_span(trace_id, span_id, 300)

    ## we have 1 span with this span name
    assert {:ok, {trace_id, span_id}} == OpentelemetryTesting.get_span_ids_by_name(span_name)
  end

  test "OpentelemetryTesting.get_spans_by_name/1 returns converted spans" do
    IO.inspect(__ENV__.function, label: :test_function_name)
    ## span_name is much longer than the names generated by SpanTreeGenerator
    span_name = elem(__ENV__.function, 0)
    span_tree_input_data = {%{name: span_name}, []}

    {span_pattern1, []} = :span_tree_builder.generate_span_tree(span_tree_input_data, & &1)
    assert {:ok, %{}} = OpentelemetryTesting.wait_for_span(:_, span_pattern1.span_id, 300)

    ## we have 1 span with this span name
    span_list1 = OpentelemetryTesting.get_spans_by_name(span_name)
    assert true == OpentelemetryTesting.match(span_list1, [span_pattern1])

    {span_pattern2, []} = :span_tree_builder.generate_span_tree(span_tree_input_data, & &1)
    assert {:ok, %{}} = OpentelemetryTesting.wait_for_span(:_, span_pattern2.span_id, 300)

    ## we have 2 spans with this span name
    span_list2 = OpentelemetryTesting.get_spans_by_name(span_name)
    assert true == OpentelemetryTesting.match(span_list2, [span_pattern1, span_pattern2])
  end
end

defmodule OpentelemetryTestingResetTest do
  use ExUnit.Case, async: false

  test "OpentelemetryTesting.reset/1 removes all collected spans" do
    IO.inspect(__ENV__.function, label: :test_function_name)
    ## span_name is much longer than the names generated by SpanTreeGenerator
    span_name = elem(__ENV__.function, 0)
    span_tree_input_data = {%{name: span_name}, [{%{name: span_name}, []}]}
    {%{span_id: span_id}, _} = :span_tree_builder.generate_span_tree(span_tree_input_data, & &1)
    assert {:ok, %{}} = OpentelemetryTesting.wait_for_span(:_, span_id, 300)

    ## we have 2 spans with this span name
    assert [%{name: span_name}, %{name: span_name}] =
             OpentelemetryTesting.get_spans_by_name(span_name)

    OpentelemetryTesting.reset()

    ## after resetting we have no spans with this span name
    assert [] == OpentelemetryTesting.get_spans_by_name(span_name)
  end
end
